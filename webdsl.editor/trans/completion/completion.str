module completion/entities

imports
  libwebdsl-front
    
strategies  
  
  editor-complete :
    a@(node, position, ast, path, project-path) -> result
    with  <editor-analyze> (ast, path, project-path) 
        ; result := <collect-all(editor-complete-proposal); flatten-list>

rules  //FieldAccess
  
  editor-complete-proposal :
    FieldAccess(e, COMPLETION(_)) -> [prop*, func*]
    where SimpleSort(typename) := <type-of> e
        ; prop* := <all-properties; map(fieldaccess-proposal-prop)> typename
        ; func* := <all-functions;  map(fieldaccess-proposal-func)> typename

  fieldaccess-proposal-prop :
    p -> result
    with  name := <get-property-name> p
        ; type := <get-property-type> p
        ; result := <prop-to-complete-proposal> (name,type)

  fieldaccess-proposal-func:
    f -> result
    with  result := <get-function-sig-full; func-sig-to-complete-proposal> f
       
rules
  
  prop-to-complete-proposal :
    (name,type) -> ([name{}],$[[name] : [<pp-type-fast> type]])     
          
  func-sig-to-complete-proposal :
    tup@(x,farg,return) -> ([sig-no-return],full-sig)
    with  sig-no-return := <pp-func-sig-arg-names-fast/*-tokens*/> (x,<map(?Arg(<id>,_))>farg)
        ; full-sig := <pp-func-sig-fast> tup
          
  pp-func-sig-arg-names-fast = ?(x,argtypes); <concat-strings> [x,"(",<separate-by(|", ");concat-strings> argtypes,")"]
  pp-func-sig-fast = ?(x,argtypes,returntype); <concat-strings> [x,"(",<map(pp-type-fast);separate-by(|", ");concat-strings> argtypes,")",<?SimpleSort("Void");!"" <+ !$[:[<pp-type-fast>]]> returntype]
  pp-type-fast : SimpleSort(x) -> x
  pp-type-fast : GenericSort(x,[SimpleSort(y)]) -> <concat-strings> [x,"<",y,">"]
  pp-type-fast : Arg(x,t) -> <concat-strings> [x," : ",<pp-type-fast> t]
     
  //returning list of tokens doesn't seem to work    
  //pp-func-sig-tokens = ?(x,argtypes); <flatten-list> [x,"(",<map(pp-webdsl-to-string);separate-by(|", ")> argtypes,")"]
  
rules //TemplateCallNoArgs
  
  //not triggered?
  editor-complete-proposal :
    TemplateCallNoArgs(COMPLETION(_)) -> []
    where debug(!"-------");all-keys-TopLevelTemplateDecl;debug 
    
rules //Var    
   
  editor-complete-proposal :
    v@Var(COMPLETION(_)) -> [var*, fun*, glo*]
    with  dbg-time(var* := <var-proposal-vars <+ ![]> v
        ; fun* := <var-proposal-funs <+ ![]> v
        ; glo* := <var-proposals-globals <+![]> v|"var completion total") 
   
  rules // vars in scope (unfortunately doesn't include globally visible vars, since put-closure-in-anno is used internally for lifting)
  
  extend rename :
    Var(COMPLETION(x)){anno*} -> Var(COMPLETION(x)){anno1*}
    with  anno1* := <put-closure-in-anno> anno*
  
  var-proposal-vars :
    Var(COMPLETION(_)){ClosureInAnno(varlist)} -> result
    with  result := <map(\v@Var(x) -> <prop-to-complete-proposal> (x,<type-of> v)\)> varlist

  rules //global, session, request vars

  var-proposals-globals :
    Var(COMPLETION(x)) -> result
    with  dbg-time(result := <all-keys-IsGlobal; map(\x -> <prop-to-complete-proposal> (x,<type-of> Var(x))\)>|"global var completion")

  rules //global functions
  
  //mainly shows internal, generated functions for simple apps, need option to sort completions
  var-proposal-funs :
    Var(COMPLETION(x)) -> result
    where <gt> (<string-length> x, 0) //don't show when there is nothing typed, too slow for that and occludes syntax completions
    with dbg-time(result := <all-keys-IsGlobalFunction;filter(not(is-string);where(?(<id>,_,_);string-starts-with(|x)));map(func-sig-to-complete-proposal)>|"global function completion")
    