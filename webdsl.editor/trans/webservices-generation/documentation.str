module webservices-generation/documentation

imports

	util 
  	lib/editor-common.generated 
  	libwebdsl-generator
  	libwebdsl-front
  	
  	webservices-generation/util
  	webservices-generation/mobl/model-to-mobl
  	webservices-generation/overlays
  	
  	entity-extraction/generate-entity-pages
  	
  	
rules
	
  generate-documentation: (selected, position, ast, path, project-path) -> None()
  	with <webdsl-editor-init> (path, project-path, ast) //cleanup DR, set appname DR
        ; <full-app-load(|<dirname> path)> ast //not using editor-analyze like other analysis tasks  
        ; <generate-mobl-model> project-path
  	with body := [<documentation-header>,<documentation-model>]
  		; <create-dir-in-workspace> "webservices" 
  		; <concat-strings; text-to-file(|"webservices/API.md")> body
  		

rules
  documentation-model: x -> documentation 
  	with header := 
  			$[Model Description
 	 		 -----------------------
 	 		 This chapter describes the entities that are used as model for the synchronization framework. This can be used to interpert the data of the expected input and output.
 			 
 			 *note:  fields with type of other objects contain ref objects of the format:*
 			 
 			 | Field | Type   |
 			 |-------|:------:|
 			 | id    | String |
 			 
 			 *note2: typeField property contains the actual type as string*
 			  
 			 ]
		; entities := <all-keys-EntDecl> None()	 
  		; filteredEntities := <filter(not(is-builtin-entity-webservices))> entities
  		; <map(EntDecl; generate-dr-for-highest-parent)> filteredEntities 
  		; completeEntities := <map(try(generate-extra-type-property)); filter(where(entity-has-no-super)); map(make-entity-with-properties)> filteredEntities
  		; body := <map(documentation-model-entity)> completeEntities	     
 		; documentation := <concat-strings> [header|body]
  	
  
  documentation-model-entity: EntityNoSuper(entityname, props) -> documentation
  	with titlelength := <add> (<string-length> entityname, 6)
 		; starttable := ("Field","Type")
 		; cleanedProps := <map(try(remove-derive-from-property); try(remove-annos-from-property))> [IdProperty1|props]  
 		; resttable := <filter(not(remove-property-with-name); prop-to-table-tuple(|entityname))> cleanedProps
 		; stringLengthFirst := <foldr(!0, max, Fst; string-length)> [starttable|resttable]
 		; stringLengthSecond := <foldr(!0, max, Snd; string-length)> [starttable|resttable] 
 		; table := <list-tuple-to-table(|stringLengthFirst, stringLengthSecond)> [starttable|resttable]
 		; documentation :=
  		  	$[###[entityname]###
  		  	[<copy-chars(|titlelength)>"-"]	
  		  	
  		  	[table]
  		  	
  		  	]	  
 		    
 		  
  list-tuple-to-table(|length1, length2): [header|rows] -> table
  	with 
  		table := 
  			$[| [<Fst> header][<filup-row(|" ")>(<Fst>header, length1)] | [<Snd> header][<filup-row(|" ")>(<Snd>header, length2)] |
			|-[<filup-row(|"-")>("", length1)]-|:[<filup-row(|"-")>("", length2)]:|
			[<map(tuple-to-row(|length1,length2))> rows]  			
  			]
  			
  tuple-to-row(|length1, length2): (first, second) -> row
  	with row := 
  		$[| [first][<filup-row(|" ")>(first, length1)] | [second][<filup-row(|" ")>(second, length2)] |
  		]
 
  filup-row(|char): (current, max) -> fill
  	with length := <subt>(max, <string-length> current)
  		; fill := <copy-chars(|length)> char
  	
  		  
  prop-to-table-tuple(|entityname): PropertyNoAnno(name, sort, type) -> (name, typestring)
	where typestring := <type-to-json-type> type

  type-to-json-type: SimpleSort(type) -> "String"
   	where <fetch(?type)> ToMoblStringTypes
  
  type-to-json-type: SimpleSort(type) -> "Number"
   	where <fetch(?type)> ToMoblNumTypes

  type-to-json-type: SimpleSort("Bool") -> "Boolean"
 
  type-to-json-type: SimpleSort(type) -> "Number"
  	where <fetch(?type)> MoblDateTimeTypes 

  type-to-json-type: SimpleSort(x_type) -> x_type
   	where x_newType := <IsEntity; find-highest-parent> x_type
   	where not (<is-builtin-entity-webservices> x_type)
  
  type-to-json-type: GenericSort(_, type) -> $<[<t_paramtype>]>
   	where <Hd; is-entity-type> type
   		; t_paramtype := <Hd; type-to-json-type> type 

rules//helpers
	
  copy-chars(|number): string -> newstring 
  	where <gt>(number,0)
  		; newstring := $[[string][<copy-chars(|<dec>number)> string]]
  		
  	
  copy-chars(|number): x -> ""	
   where not (<gt>(number,0))
   
   
  remove-annos-from-property: p@Property(x_name, sort, type, annos) -> PropertyNoAnno(x_name, sort, type)
  
  remove-property-with-name: p@PropertyNoAnno("sync", sort, type) -> p
  
  remove-property-with-name: p@PropertyNoAnno("lastSynced", sort, type) -> p
  
  remove-property-with-name: p@PropertyNoAnno(name, sort, type) -> p
  	where <string-starts-with(|"generatedPropertyForInverse_")> name
  
rules//overlays
	
 documentation-header = !
	${API Webservices Synchronization Framework
 	  ==============================================
 	  This document describes the webservices interface that is part of the generated synchronization framework. The goal of this document is explanation of the webservices for usage of 3th party apllications.
 	  
 	  The following information is described in this document:
 	  
 	  + General Webservice Information
 	  + Model Description
 	  + WebService Description
 	  
 	  General Webservice Information
 	  ---------------------------------
 	  
 	  The generated services are simple, which means they do not contain many parameters to specify all kind of options on the requested data. The services are meant for synchronization. Nevertheless, they can also be used for requesting of data.

 	  ### Interface ###

 	  All the webservices are available through the following link:
	 
 	  http(s)://<base.url>/webservice/<webservicename>

 	  
 	  *The services are based on JSON and only support post requests*

 	  The default format for all services is:

 	  | field name | type     | explanation               |
 	  |------------|:--------:|---------------------------|
 	  | errors     | [String] | List of error messages    |
 	  | result     | Any      | the result of the service |

 	  
 	  ### Control Flow ###

 	  The first time using the synchronization the following steps are expected:

 	  + possible authentication
 	  + request the toplevel entities for partition selection.
 	  + request timestamp
 	  + request for all entities the objects of the selected partitions 
 	  
 	  Further synchronization contains the following steps:

 	  + send the new objects to the server
 	  + send the updates of modified objects to the server
 	  + request timestamp
 	  + request for all entities the objects of the selected partitions	
 	    	
 }
 
 
    