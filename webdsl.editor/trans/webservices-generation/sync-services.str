module webservices-generation/sync-services
imports 
    	webservices-generation/interface
    	webservices-generation/util
  	  	util 
	  	lib/-
rules 
	
  generate-sync-services(|topLevelEntity): x -> x
	where 	entities := <all-keys-EntDecl> None()	  
  			; filteredEntities := <filter(not(is-builtin-entity))> entities   
  			; <map(generate-sync-service(|topLevelEntity))> filteredEntities
  			; <generate-edit-sync-service> filteredEntities  
   			  
   			  
  generate-sync-service(|x_topLevelEntity): x_entityname -> x_entityname
  	where 	name := $[sync[x_entityname]]
  			; e_name :=  String(x_topLevelEntity)
  			; stat_forloop :=  <generate-sync-for-entity-loop(|x_topLevelEntity)>x_entityname
  			; stat_childloop := <get-subclasses-of-entity; map(generate-sync-for-entity-loop(|x_topLevelEntity, x_entityname))>  x_entityname 	
      		; body := webdsl 
	      	  |[
	      	  	var request := JSONArray(readRequestBody()) ;
	  			var result := JSONArray() ;
	  			for ( count : Int from 0 to request.length() ){
	  				var tl := ( loadEntity(e_name, request.getJSONObject(count).getString("id").parseUUID()) as x_topLevelEntity ) ;
	  				var timestamp := request.getJSONObject(count).getLong("lastSynced") ;
	  				stat_forloop
					stat_childloop
	  			}
	  		  ]|   			 
	       	; service := <generate-service(|name)> body
	        ; service-to-file(|name) 
	          
  generate-sync-for-entity-loop(|toplevelEntity, x_superClass): x_entity  -> statement
  	where 	x_functionname := $[getAll[x_entity]For[toplevelEntity]]
  			; x_functionnamejson := $[toJSONFromSuper[x_superClass]]
  			; statement :=  stat 
	      	  |[
	      	  	for(ent: x_entity in x_functionname(tl) where timestamp == 0 || (ent.modified != null && ent.modified.getTime() > timestamp )){
	  				result.put(addDirtyFalse(ent.x_functionnamejson()));
	  			}
	      	  ]|
  
  generate-sync-for-entity-loop(|toplevelEntity): x_entity  -> statement
  	where 	x_functionname := $[getAll[x_entity]For[toplevelEntity]]
  			; statement :=  stat 
	      	  |[
	      	  	for(ent: x_entity in x_functionname(tl)where timestamp == 0 || (ent.modified != null && ent.modified.getTime() > timestamp ) ){
	  				result.put(addDirtyFalse(ent.toJSON()));
	  			}
	      	  ]|
rules //edit	      	  
  generate-edit-sync-service: entities -> entities
	where	stat_ifs := <generate-ifs-for-checking-type> entities
			; name := "syncDirtyObjects"
			; body := webdsl 
	      	  |[
	      	  	var request := JSONArray(readRequestBody()) ;
	      	  	var result := JSONArray();
				for ( count : Int from 0 to request.length() ) {
					var jsontemp := request.getJSONObject(count);
				  	var kind := jsontemp.getString("name");
				  	var entities := jsontemp.getJSONArray("value");
					stat_ifs
				  		//is not already edited
				  		//may edit
				  		// var entity := ( loadEntity("Project", projects.getJSONObject(count).getString("id").parseUUID()) as Project ) ;
				  		// editedProject(entity, projects.getJSONObject(count));
				  		// 
  				}
	  		  ]|
	  		; service := <generate-service(|name)> body
	        ; service-to-file(|name)    			      	  
	
 generate-ifs-for-checking-type: [] -> statement
 	where 	statement :=  webdsl |[errors.put("type is undefined: " + kind);]|    
 	
 generate-ifs-for-checking-type: [x|xs] -> statement
 	where	stat_elseblock := <generate-ifs-for-checking-type> xs
 			; x_entityname := String(x)
 			; x_mappername := $[mapperEdited[x]]
 			; statement :=  webdsl 
 			  |[
 			  	 if(kind == x_entityname) {
				  		for ( count : Int from 0 to entities.length() ) {
				  			var entity := ( loadEntity(x_entityname, entities.getJSONObject(count).getString("id").parseUUID()) as x ) ;
				  			if (entity.version <= entities.getJSONObject(count).getInt("version")) {
				  				x_mappername(entity, entities.getJSONObject(count));
				  			} else {
				  				errors.put(makeJSONErrorObject("already has newer version", ErrorTypes.Warning, x_entityname, entity.id));
				  			}
				  		}
				  	} else {
				  		stat_elseblock
				  	}
 			  ]|   		  