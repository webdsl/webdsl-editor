module fact-extraction/datalog

imports
   libwebdsl-front
   libwebdsl-generator
   typecheck/template
   webdsl_editor
   resolve/function

signature constructors
  
  Fact : Id * List(Constant) -> Term

rules
   
  datalog-extraction :
    a@(node, position, ast, path, project-path) -> (filename, result)
    with  filename := <guarantee-extension(|"aterm")> path
    with  <editor-analyze> (ast, path, project-path)
        ; entity* := <all-keys-EntDecl; map(!Fact("entity",[<id>]))>  //map(!$[entity('[<id>]').]); concat-strings>
        ; property* := <all-keys-TypeOfProperty; map(!Fact("property",[<Fst>, <Snd>, <TypeOfProperty; pp-type>]))>
        ; entityfunction* := <all-keys-Functions; mapconcat(extract-entity-functions)>
        ; globalfunction* := <all-keys-FunctionDecl; mapconcat(FunctionDecl; extract-global-function)>
        ; super* := <all-keys-EntDecl; filter(!Fact("super",[<Extends>,<id>]))>
        ; pagesig* := <all-keys-PageDecl; mapconcat(PageDecl; extract-page)>
        ; templatesig* := <all-keys-CurrentTemplateDecl; mapconcat(CurrentTemplateDecl; extract-template)> //CurrentTemplateDecl contains 'renamed' template bodies
        ; result := <map(pp-datalog); concat-strings> [entity*,super*,property*,entityfunction*,pagesig*,templatesig*,globalfunction*]
        //; result := <bagof-Properties; map(pp-webdsl-to-string); concat-strings> "Test" // <collect-all(?Define(_,_,_,_,_)); flatten-list>
  
rules
  
  extract-page:
    Define(mod*, name, fargs, targs, body) -> [Fact("page",[name])| [argfact*,callfact*]]
    with argfact* := <add-indices; map(extract-page-arg(|name))> fargs
    with callfact* := <extract-template-body-calls(|name, body)>
    
  extract-page-arg(|page):
    (num,Arg(name,type)) -> Fact("pageargument", [page, num, name, <pp-type> type])
    
  extract-template:
    Define(mod*, name, fargs, targs, body) -> [Fact("template", [uniqname, name]) | [argfact*,callfact*]]
    with uniqname := <get-template-unique-name-from-define>
    with argfact* := <add-indices; map(extract-template-arg(|uniqname))> fargs
    with callfact* := <extract-template-body-calls(|uniqname, body)>
    
  extract-template-arg(|uniqname):
    (num,Arg(name,type)) -> Fact("templateargument", [uniqname, num, name, <pp-type> type])
    
  extract-template-body-calls(|uniqname,body) :
    _ -> facts
    with calls := <collect(is-defined-tc-get-called-tc)> body
       ; facts := <map(!Fact("templatecall",[uniqname,<id>]))> calls

  get-template-unique-name-from-define :
    Define(mod*, name, fargs, targs, body) -> uniqname
    with uniqname := <generate-template-name-fargs>(name, fargs)

rules  
  
  extract-entity-functions:
    ent -> funs
    where funs := <bagof-Functions; mapconcat(extract-entity-function(|ent))> ent
      
  extract-entity-function(|ent):
    fun -> [Fact("entityfunction", [ent, uniqname, name, <pp-type>ret]) | [argfact*,callfact*]]
    where (uniqname,name,args,ret) := <get-function-sig-unique-name> fun
        ; argfact* := <add-indices; map(extract-entity-function-arg(|ent,uniqname))> args
    with  if body := <extract-function-body> fun
          then callfact* := <extract-entity-function-body-calls(|ent,uniqname,body)>
          else callfact* := [] end
    
  get-function-sig-unique-name:
    fun -> (uniqname,name,args,ret)
    with (name,args,ret) := <get-function-sig-full> fun
       ; uniqname := <new-function-name> (name, <map(farg-to-type)> args)      
      
  extract-entity-function-arg(|ent,uniqname):
    (num,Arg(name,type)) -> Fact("entityfunctionargument", [ent, uniqname, num, name, <pp-type> type])

  //reusing resolve code 
  extract-entity-function-body-calls(|ent,uniqname,body) :
    _ -> [factglobal*,factent*]
    with callsglobal := <collect(?ThisCall(_,_);declaration-of)> body 
       ; factglobal* := <map(get-function-sig-unique-name;Fst;!Fact("functioncallentitytoglobal",[ent,uniqname,<id>]))> callsglobal
    with callsent := <collect(?ThisCall(_,_);declaration-in-entity(|ent);!(ent,<id>) <+ ?Call(_,_,_);declaration-of;!(<get-anno(?FromEntity(_));?FromEntity(<id>)>,<id>))> body
       ; factent* := <map((id,get-function-sig-unique-name;Fst);!Fact("functioncallentitytoentity",[ent,uniqname,<Fst>,<Snd>]))> callsent

  extract-function-body = 
       \Function(x,farg,_,body) -> body\
    <+ \FunctionNoReturn(x,farg,body) -> body\
    <+ \Predicate(x,farg,body) -> body\
    <+ \PredicateInEntity(x,farg,body) -> body\
    <+ \NativeFunction(x,farg,body) -> body\
    <+ \StaticEntityFunction(x,farg,_,body) -> body\
    
rules
  
  extract-global-function:
    fun -> [Fact("globalfunction", [uniqname, name, <pp-type>ret]) | [argfact*,callfact*]]
    where (uniqname,name,args,ret) := <get-function-sig-unique-name> fun
        ; argfact* := <add-indices; map(extract-global-function-arg(|uniqname))> args
    with  if body := <extract-function-body> fun
          then callfact* := <extract-global-function-body-calls(|uniqname,body)>
          else callfact* := [] end 

  extract-global-function-arg(|uniqname):
    (num,Arg(name,type)) -> Fact("globalfunctionargument", [uniqname, num, name, <pp-type> type])

  //reusing resolve code 
  extract-global-function-body-calls(|uniqname,body) :
    _ -> [factglobal*,factent*]
    with callsglobal := <collect(?ThisCall(_,_);declaration-of)> body 
       ; factglobal* := <map(get-function-sig-unique-name;Fst;!Fact("functioncallglobaltoglobal",[uniqname,<id>]))> callsglobal
    with callsent := <collect(?Call(_,_,_);declaration-of;!(<get-anno(?FromEntity(_));?FromEntity(<id>)>,<id>))> body
       ; factent* := <map((id,get-function-sig-unique-name;Fst);!Fact("functioncallglobaltoentity",[uniqname,<Fst>,<Snd>]))> callsent

rules
  
  pp-datalog : 
    Fact(name,cs) -> $[[name]([args]).
    ]
    with args := <not(is-list);debug(!"Fact(_,X) must be a list: ");fail 
                  <+ 
                  map(is-string; single-quote <+ is-int; int-to-string <+ debug(!"Fact(_,[..,X,..]) must be String or Int: ");fail); 
                  separate-by(|","); 
                  concat-strings>cs
    