module webdsl_editor

imports
  libstratego-lib
  libwebdsl-generator
  libwebdsl-front
  parse
  application-ini
  util
  caching
  typechecker
  typecheck/import		// for ExtraWarnings
	resolve
	dependencies
  
signature constructors
  FILE : Term -> Term
  
strategies // editor service interface

  main-webdsl =
     fatal-err(|"Not designed to be invoked directly")
  
  editor-check(|fullpath): ast -> (ast-renamed, errs, warns, notes)
    with  rename-top => ast-renamed
        // Typecheck local
      ; {| ModulesUsed, ExtraWarnings:
	          enable-dr-usage-tracking
	       // ; not(find-extra-errors)       // collected in dr
	       //; warn3 := <bagof-ExtraWarnings>
          ; (err1, warn1) := 
	            <dbg-time(catch-errors-editor(constraint-error-all) | "typecheck")>
	        ; disable-dr-usage-tracking
	        ; where(
	            all-keys-ModulesUsed => mods
	          ; debug(!".. modules used: ")
	          ; rules(ModulesUsedBy : fullpath -> mods)
	        )
        |}
        // Typecheck global
      ; (err2, warn2) := <catch-errors-editor(not(<constraint-error-global> ""))>
      ; errs := <concat> [err1,err2]
      ; warns := <concat> [warn1,warn2]
      ; notes := []
      
  // Path is relative to project, without leading slash
  // Projectpath is an absolute path to the project root, without trailing slash
  editor-analyze:
    (ast, path, projectpath) -> (ast-desugared, errors, warnings, notes)
    with
      where(!""; debug)
    ; disable-dr-usage-tracking     // avoid overhead
      // Do not lose the cached definitions
    ; where(
 //         rulesets := <map(save-rule-set)> ["ModuleDefs", "ModuleDefsTc", "ModuleCacheTimestamp"];
          try(dr-scope-all-end); dr-scope-all-start
 //       <map(restore-rule-set)> rulesets
      )
    ; fullpath := <concat-strings> [projectpath, "/", path]
    ; rules(
        AnalyzeFile := path     // path within project
        FullPath := fullpath    // full filename
      )
    
    ; <desugar-compat> ast
    ; in-typechecking-phase(
        
        // Set up built-in types before doing any declares
	      typecheck-init
	      
	      // Declare this module (processes transitive imports)
	    ; get-main-import
	    ; {| CurrentFile:
		       rules(CurrentFile := fullpath)
	        ; where(
	            declare-globals => (ruleset, imports)
	          ; cache-path := <import-cache-path> fullpath
	          ; <WriteToBinaryFile> (cache-path, (ruleset, imports))
	        )
	      |}

	    ; typechecker-after-declare
	    ; editor-check(|fullpath) => (ast-renamed, err1, warnings, notes)
      
      ; bagof-ModulesToCheck    // pairs of (fullpath, ast)
      ; map(\(fullpath-mod, ast-mod) -> <!fullpath-mod; debug(!"Checking import: "); !ast-mod; editor-check(|fullpath-mod)> ast-mod \)      // sets <ModulesUsed> fullpath2
      
    )
    ; ast-desugared := <dbg-time(desugar-all | "resolving")> ast-renamed    // declare for resolving
    
    ; errors := <concat> [err1, <bagof-ImportErrors>]
      
      // create dependency graph
    ; update-dependency-graph
      
    ; print-total-log-time
    ; enable-dr-usage-tracking      // for dr -> module resolving
      
  find-extra-errors = fail
  
  desugar-all =
      preserve(innermost(desugar-def))
  
  import-main-file: ast -> ast
    with  appname := <AppName>
        ; mainapp := <concat-strings> [<ApplicationIniDir>, "/", appname, ".app"]
          // TODO: does this work on windows too ? (/ vs. \)
        ; where(!appname; debug(!"Explicitely importing main file: ")) 
        ; <get-imports> Imports(appname)
          
  add-app-ini-error: ast -> ast
    with rules(ImportErrors :+= (ast, "Cannot find application.ini"))
             
  get-main-import: ast -> ast
    with  FullPath => fullpath
        ; rules(IsImported : fullpath) // do not transitively import the analyzed file
        ; {| ParsingModule:
              rules(ParsingModule := fullpath)
              // try to import main file if we're parsing a module
            ; !ast
            ; try(
              	 // get-main-file-name also sets ApplicationIniDir
                  where(get-main-file-name <+ add-app-ini-error; fail)
                  // if checking a module, import main app file
                ; ?Module(_,_); import-main-file
              )
	      |}
 
  get-imports: 
    imp@Imports(x) -> imp
    where {| TopImport: 
     		where(try(not(TopImport); rules(TopImport := imp)))
      ; <editor-parse-webdsl-module> (<concat-strings> [x,".app"])
   	|}