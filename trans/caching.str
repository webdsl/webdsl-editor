module caching

imports
    parse
    ../lib/editor-common.generated
    libwebdsl-front
    util
    webdsl_editor

strategies  
  
  // Already stored
  store-imported-def: def -> def
    where mod := <CurrentFile>
        ; <ReadingFromCache> mod
        ; <store-def-to-mod> def
        
  store-imported-def: def -> def
    where mod := <CurrentFile>
        ; sig := <alltd(strip-bodies)> def
        //; rules(ModuleDefs :+ mod -> sig)
        ; <store-def-to-mod> def
  
  store-def-to-mod-desugar = desugar-all; store-def-to-mod
  store-def-to-mod-desugar(|ent) = desugar-all; add-anno(|FromEntity(ent)); store-def-to-mod
        
  store-def-to-mod: def -> def
    where mod := <CurrentFile>
        //; rules(DefToModule :+ def -> mod)
        
  // For main app, do not remember anything
  store-imported-def = id
    
strategies // storing for compiler typechecker
  
  // Already stored
  store-tc-def: def -> def
    where mod := <CurrentFile>
        ; <ReadingFromCache> mod
 
  store-tc-def: def -> def
    where mod := <CurrentFile>
        //; rules(ModuleDefsTc :+ mod -> def)
  
  // For main app, do not remember anything
  store-tc-def = id

signature constructors
  
  // Wrap int in ModificationTerm to avoid LazyTerm bug
  ModificationTime : Term -> Term

strategies

  check-editor-version: cache-path -> cache-path
// NATHAN: disable until Spoofax/92 is solved. [http://yellowgrass.org/issue/Spoofax/92]
//    with  ModificationTime(editor-ts) := <import-term(editor.timestamp.aterm)>
    with editor-ts := 1271360674
    where <gt <+ editor-new-version-once; fail> (<modification-time> cache-path, editor-ts)
    
  editor-new-version-once =
    try(
        where(not(EditorNewVersionShowed))
      ; rules(EditorNewVersionShowed := True())
      ; debug(!"Editor is updated; refreshing cache.")
    )

  /* Custom version of open-import */
  open-import-sig(resolve-path, parse-file, record-declarations, record-sigs):
    import -> import
    where
      if not(!import => COMPLETION(_)) then
        path       := <resolve-path> import;
        cache-path := <import-cache-path> path;
        {| CurrentFile:
          rules(CurrentFile := path);
          if not(<IsImported> path) then
	          rules(
	            IsImported: path
	          ); 
	          if   <is-newer> (cache-path, path); <check-editor-version> cache-path then
	            file := <log-time-helper(ReadFromFile | "read")> cache-path;
	            <record-sigs> file 
	          else
	            where(!cache-path; debug(!"Updating cache: "));
	            file := <parse-file> path;
	            sigs := <record-declarations> file;
	            if <file-exists> path then
	              // Only cache if on filesystem (e.g., ignore libstratego-lib)
	              <WriteToBinaryFile> (cache-path, sigs)
	            end
	          end
	        end
        |}
      end
      
strategies
  
  /*
  open-memory-cache(resolve-path, parse-file, record-declarations) =
      where(fullpath := <resolve-path>)
    ; open-memory-cache(parse-file, record-declarations | fullpath)
  
  open-memory-cache(parse-file, record-declarations | fullpath) =
     where(<IsImported> fullpath)
  
  open-memory-cache(parse-file, record-declarations | fullpath): modulename -> modulename
  where ts := <ModuleCacheTimestamp> fullpath
      ; modtime := <modification-time> fullpath
      ; <eq> (ts,modtime)
   with where(!modulename; debug(!"Using in-mem cache: "))
      ; {| ReadingFromMemoryCache:
            rules(ReadingFromMemoryCache := True())
            // typecheck
          ; tc-ast := <log-time-helper(bagof-ModuleDefsTc | " get bag1")> fullpath
          //; debug(!"TC AST: ")
          ; <log-time-helper(alltd(declare-global <+ declare-global-toplevel) | "declare global")> tc-ast
            // resolving
          ; ast := <log-time-helper(bagof-ModuleDefs | " get bag2")> fullpath
          //; debug(!"AST: ")
          ; <alltd(try(get-imports); log-time-helper(declare-def | "declare def"); ensure-ast(|"after declare"))> ast
        |}
      ; rules(IsImported : fullpath)

  open-memory-cache(parse-file, record-declarations | fullpath): modulename -> modulename
   with modtime := <modification-time> fullpath
      ; where(!fullpath; debug(!"No in-memory cache for: "))
      ; file := <log-time-helper(parse-file | "parse file")> fullpath
      ; ensure-ast(|"after parse")
      ; <preserve(try(fix-module-name(|fullpath))); check-ast(|"after fix"); record-declarations> file
      ; rules(IsImported: fullpath)
      ; rules(ModuleCacheTimestamp :+ fullpath -> modtime)
  */
  
  fix-module-name(|fullpath): Module(name, sections) -> Module(name2, sections)
    where name2 := <fix-module-name> (fullpath, name)
  fix-module-name(|fullpath): ModuleDefs(name, defs, sections) -> ModuleDefs(name2, defs, sections)
    where name2 := <fix-module-name> (fullpath, name)
    
  fix-module-name: (fullpath, modname) -> newname
    with base := <concat-strings> [<ApplicationIniDir <+ prim("SSL_EXT_projectpath")>, "/"]
    where (l,r) := <split-after> (fullpath, base)
        ; not(<eq> (r, "")) // base not found
        ; newname := <split-before; Fst> (r, ".app")
        ; not(<eq> (newname, modname))
        ; <concat-strings; debug> ["Renaming module '",modname,"' to '",newname,"'."]
        
strategies // dr utils

/*
  iset-copy =
     elems := <iset-elements>
   ; count := <length> elems
   ; newset := <new-iset(|count,75)>
   ; <iset-addlist(|elems)> newset
  
  save-rule-set: name -> (name, RuleScope(newset, newtable))
   with  RuleScope(set, table) := <dr-get-rule-set(|name); Hd>
       ; newset := <iset-copy> set
       ; newtable := <hashtable-copy> table
       
  dr-set-last-scope-rule-set(|name): ruleset -> ruleset
   with [firstscope | restscopes] := <dr-get-rule-set(|name)>
      ; <dr-destroy-scope> firstscope
      ; ![ruleset | restscopes]
      ; dr-set-rule-set(|name)

  restore-rule-set: (name,ruleset) -> <id>
   with <dr-set-last-scope-rule-set(|name)> ruleset
*/
strategies // bench
  
   dbg-time(s|msg) =
      where(starttime := <times>)
    ; s
    ; where(
          total := <diff-times> (<times>,starttime)
        ; t1 := <self-children-user-time; ticks-to-seconds; real-to-string(|3)> total
        ; str := <concat-strings> [msg, ": ", t1, " s"]
        ; debug
      )