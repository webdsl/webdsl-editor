module parse

imports 
  libwebdsl-front 
  libwebdsl-generator
  libstratego-sglr
  lib/editor-common.generated
  webdsl_editor
  application-ini
  caching
  util
  dr
  typecheck/import

rules
  
  format-trace(|prefix) =
  		map(\name -> <concat-strings> [prefix, name]\)
  	; separate-by(|"<br/>")
  	; concat-strings
  	; try(not(?""); <concat-strings> ["<br/>", <id>])
  
  report-import-failed(|txt): fullpath -> <fail>
  	with 	trace-entries := <bigbagof-CurrentFile>
  	    ; trace := <format-trace(|"... imported from: ")> trace-entries
  	    ; msg := <concat-strings> [txt, ": ", fullpath, trace]
  		  ; import := <TopImport <+ !"DummyImport(main-app)">
  		  ; rules(ImportErrors :+= (import, msg))

  import-to-fullpath: x -> $[[<ApplicationIniDir>]/[x].app]
  			
  editor-parse-webdsl-module: x -> x
  	where(
    		full-path := <import-to-fullpath> x
    	; <file-exists <+ report-import-failed(|"Imported file not found")> full-path
   	)
  ; (open-import-sig(
    		!full-path
    	, log-time-helper(parse-file | "parse")
    	, read-import(|full-path)
    	, read-import-sigs)
      <+
    	 <report-import-failed(|"Could not import file")> full-path
    )
    
  all-used-drs = !<import-term(include/webdsl-typechecker-rules.aterm)>
  is-used-dr = ?"ModuleDecl"
 
  is-used-dr = ?x; where(all-used-drs; fetch-elem(?x))
  
  get-transitive-import: imp@Imports(x) -> imp
  	with <get-imports> imp
  
  read-import(|fullpath) =
      desugar-compat  // simplify module/app constructor
    ; preserve(try(fix-module-name(|fullpath)))
    ; where(alltd(origin-strip); ?ast-unstripped)
    //; try(alltd(strip-bodies))
    ; where(declare-globals => (ruleset, imports))
      // TODO: stripping of built-in functions
    ; rules(ModulesToCheck :+= (fullpath, ast-unstripped))
    ; !(ruleset, imports)
      
  strip-dr-bodies =
    map(\(key,vals) -> (key,<map(\val -> <try(alltd(strip-bodies))> val\)> vals) \)
      
  declare-globals =
      where(
        imports := <collect(?Imports(_))>
      ; filter(get-imports)
    )
    ; start-record-dynamic-rules
		;	desugar-compat
	  ; try(where(store-module))
		; typecheck-declare
		; end-record-dynamic-rules
		; filter(where(Fst; is-used-dr))
		  // strip bodies of generated definitions
		; strip-dr-bodies
		; set-module-for-rule-closure
		; !(<id>, imports)
		  
  read-import-sigs: (ruleset, imports) -> (ruleset, imports)
    with <log-time-helper(load-dynamic-rule-closure | "load drs")> ruleset
       ; <map(get-imports)> imports
       
  // Try subnodes before stripping the node
  find-node(|sig): node -> res
    where <one(find-node(|sig); ?res)> node
      <+  preserve(strip-bodies); ?sig; ?res
      <+  ?sig; ?res

  get-imported-decl(|mod): sig -> node
    with  ast := <log-time-helper(parse-file <+ debug(!"Parsing failed") | "parse")> mod
        ; if <?Module(_,_)> sig then
              node := ast
          else
              <log-time-helper(preserve(desugar-all)
                  <+ debug(!"desugar failed")
                | "desugar")> ast
            ; node := <log-time-helper(find-node(|sig)
                | "find node desugared ast")>
          end
        ; print-total-log-time
        ; <ensure-ast(|"after get-imported-decl")> node